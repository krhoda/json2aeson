import React, {useState} from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { gruvboxDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';

const SnippetHolder = (props) => {
	let {target, targetName, updateError, updateConsume} = props;
	let [badWord, setBadWord] = useState(false);

	let name = targetName;
	if (!name) {
		name = 'AutoGenerated';
	}

	if (!target) {
		return '';
	}

	try {
		let parsedTarget = JSON.parse(target);
		let targetObj = createRecordObject(parsedTarget, toPascalCase(name), updateError, setBadWord);
		if (!targetObj) {
			return '';
		}

		let fileHeader = makeFileHeader(name, badWord);

		let snippetBody = renderRecordObj(targetObj);
		return (
			<div>
				<SyntaxHighlighter className="snippet" language="haskell" style={gruvboxDark}>
					{fileHeader + snippetBody}
				</SyntaxHighlighter>
			</div>
		);
	} catch (err) {
		updateConsume('');
		updateError(`Cannot parse input ${err}`);
		return <p>Error encountered!</p>;
	}
};

const createRecordObject = (target, recordName, updateError, setBadWord) => {
	let targetKeys = Object.keys(target);
	let targetLen = targetKeys.length;

	let recordBody = [];
	let nestedModels = [];
	let badWordList = [];
	let hasBadWord = false;

	targetKeys.forEach((key, i) => {
		let value = target[key];

		let badWord = checkForBadWords(key);
		if (badWord) {
			setBadWord(true);
			let oldKey = key;
			key = `${recordName.toLowerCase()}_${key}`;

			let nextBadWordEntry = {
				oldWord: oldKey,
				newWord: key
			};

			hasBadWord = true;
			badWordList.push(nextBadWordEntry);
		}

		let valType = '';

		switch (typeof value) {
		case 'string':
			valType = `\t${key} :: Text,\n`;
			break;
		case 'boolean':
			valType = `\t${key} :: Bool,\n`;
			break;
		case 'number':
			valType = `\t${key} :: Number,\n`;
			break;
		case 'object':
			if (Array.isArray(value)) {
				let {body, nested} = handleArrayField(value, toPascalCase(key), updateError, setBadWord);

				valType = (body);
				if (nested) {
					nestedModels.push(nested);
				}
				break;
			}

			let nextModelRecord = createRecordObject(value, toPascalCase(key), updateError, setBadWord);


			valType = `\t${key} :: ${toPascalCase(key)},\n`;
			nestedModels.push(nextModelRecord);
			break;
		default:
			console.error('Unexpected type heard: ' + typeof value);
		}

		if (i == targetLen - 1) {
			valType = valType.replace(/,/g, "");
		}
		recordBody.push(valType);
	});

	updateError('');

	return {
		name:         recordName,
		recordBody:   recordBody,
		nestedModels: nestedModels,
		hasBadWord: hasBadWord,
		badWordList: badWordList
	};
};

const handleArrayField = (value, key, updateError, setBadWord) => {
	// TODO: something
	let insideType = `\t${key} :: (),\n`;
	let nestedModel = false;
	if (value.length > 0) {
		let testValue = value[0];
		switch (typeof testValue) {
		case 'string':
			insideType = `\t${key.toLowerCase()} :: [Text],\n`;
			break;
		case 'boolean':
			insideType = `\t${key.toLowerCase()} :: [Bool],\n`;
			break;
		case 'number':
			insideType = `\t${key.toLowerCase()} :: [Number],\n`;
			break;
		case 'object':
			insideType = `\t${key.toLowerCase()} :: [${toPascalCase(key)}],\n`;
		    nestedModel = createRecordObject(testValue, key, updateError, setBadWord)
			break;
		}
	}

	return {body: insideType, nested: nestedModel};
};

const upperFirst = (s) => {
	return s.charAt(0).toUpperCase() + s.substr(1);
}

const toPascalCase = (str) => {
	let noSpace = str.split(' ').map(upperFirst).join('');
	let noDash = noSpace.split('-').map(upperFirst).join('');
	let noUnder = noDash.split('_').map(upperFirst).join('');

	return noUnder;
};

const checkForBadWords = (word) => {
	for (let i = 0, x = badWords.length; i < x; i++)  {
		if (word === badWords[i]) {
			return word;
		}
	}

	return false;
};

const badWords = [
	'case',
	'class',
	'data',
	'default',
	'deriving',
	'do',
	'else',
	'forall',
	'id',
	'if',
	'import',
	'in',
	'infix',
	'infixl',
	'infixr',
	'instance',
	'let',
	'module',
	'newtype',
	'of',
	'qualified',
	'then',
	'type',
	'where',
	'_',
	'foreign',
	'ccall',
	'as',
	'safe',
	'unsafe'
];

const makeFileHeader = (name, badWord) => {
	let extensions = "{-# LANGUAGE DeriveGeneric #-}"
	let extraAeson = "";

	if (badWord) {
		extensions += "\n{-# LANGUAGE TemplateHaskell #-}"
		extraAeson = "\nimport Data.Aeson.TH (deriveJSON, defaultOptions, Options(fieldLabelModifier))\n"
	}

	return `${extensions}

module ${name} where

import Data.Aeson${extraAeson}
import Data.Text (Text)

import GHC.Generics (Generic)

`;
};

const makeDataHeader = (name) => {
	return `data ${name} = ${name} {\n`;
};

const makeDataFooter = (recordObj) => {
	let prefix = "} deriving (Show, Eq, Generic)\n\n"
	if (recordObj.hasBadWord) {
		console.log("HERE:");
		let cases = recordObj.badWordList.map(makeTemplateFooter).join("\n");

		return `${prefix}$(deriveJSON defaultOptions {fieldLabelModifier = \\x ->\n\tcase x of\n${cases}\n\t_ -> x} ''${recordObj.name})\n\n`;
	}

	return `${prefix}instance FromJSON ${recordObj.name}\n\n`;
};

const makeTemplateFooter = (badWordEntry) => {
	return `\t"${badWordEntry.newWord}" -> "${badWordEntry.oldWord}"`;
}

const renderRecordObj = (recordObj) => {
	let others = recordObj.nestedModels.map((x) => {
		return renderRecordObj(x);
	});

	return `${others}${makeDataHeader(recordObj.name)}${recordObj.recordBody.join('')}${makeDataFooter(recordObj)}`;
};

export default SnippetHolder;
