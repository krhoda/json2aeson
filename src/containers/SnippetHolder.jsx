import React, {useState} from 'react';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { gruvboxDark } from 'react-syntax-highlighter/dist/esm/styles/hljs';

const initState = {badWord: false};

const SnippetHolder = (props) => {
	let {target, targetName, updateError, updateConsume} = props;

	let [state, setState] = useState([ {...initState} ]);

	const setStateField = (nextKey, nextValue) => {
		let update = {};
		update[nextKey] = nextValue;

		let lastValue = state[nextKey];
		if (lastValue === nextValue) {
			return;
		}

		let nextState = Object.assign({}, state, update);
		setState(nextState);
	}

	const updateBadWord = (nextValue) => {
		setStateField('badWord', nextValue);
	}

	let name = targetName;
	if (!name) {
		name = 'AutoGenerated';
	}

	if (!target) {
		return '';
	}

	try {
		let parsedTarget = JSON.parse(target);
		let targetObj = createRecordObject(parsedTarget, toPascalCase(name), updateError, updateBadWord);
		if (!targetObj) {
			return '';
		}

		let fileHeader = makeFileHeader(name, state.badWord);

		let snippetBody = renderRecordObj(targetObj);
		return (
			<div>
				<SyntaxHighlighter className="snippet" language="haskell" style={gruvboxDark}>
					{fileHeader + snippetBody}
				</SyntaxHighlighter>
			</div>
		);
	} catch (err) {
		updateConsume('');
		updateError(`Cannot parse input ${err}`);
		return <p>Error encountered!</p>;
	}
};

const createRecordObject = (target, recordName, updateError, updateBadWord) => {
	let targetKeys = Object.keys(target);
	let targetLen = targetKeys.length;


	let recordBody = [];
	let nestedModels = [];
	let badWordList = [];
	let hasBadWord = false;

	targetKeys.forEach((key, i) => {
		let value = target[key];

		let badWord = checkForBadWords(key);
		if (badWord) {
			updateBadWord(true);
			let oldKey = key;
			key = `${recordName.toLowerCase()}_${key}`;

			let nextBadWordEntry = {
				oldWord: oldKey,
				newWord: key
			};

			hasBadWord = true;
			badWordList.push(nextBadWordEntry);
		}

		let valType = '';

		switch (typeof value) {
		case 'string':
			valType = `\t${key} :: Text,\n`;
			break;
		case 'boolean':
			valType = `\t${key} :: Bool,\n`;
			break;
		case 'number':
			valType = `\t${key} :: Number,\n`;
			break;
		case 'object':
			if (Array.isArray(value)) {
				let {body, nested} = handleArrayField(value, toPascalCase(key), updateError, updateBadWord);

				valType = (body);
				if (nested) {
					nestedModels.push(nested);
				}
				break;
			}

			let nextModelRecord = createRecordObject(value, toPascalCase(key), updateError, updateBadWord);


			valType = `\t${key} :: ${toPascalCase(key)},\n`;
			nestedModels.push(nextModelRecord);
			break;
		default:
			console.error('Unexpected type heard: ' + typeof value);
		}

		if (i == targetLen - 1) {
			valType = valType.replace(/,/g, "");
		}
		recordBody.push(valType);
	});

	updateError('');

	return {
		name:         recordName,
		recordBody:   recordBody,
		nestedModels: nestedModels,
		hasBadWord: hasBadWord,
		badWordList: badWordList
	};
};

const handleArrayField = (value, key, updateError, updateBadWord) => {
	// TODO: something
	let insideType = `\t${key} :: (),\n`;
	let nestedModel = false;
	if (value.length > 0) {
		let testValue = value[0];
		switch (typeof testValue) {
		case 'string':
			insideType = `\t${key} :: [Text],\n`;
			break;
		case 'boolean':
			insideType = `\t${key} :: [Bool],\n`;
			break;
		case 'number':
			insideType = `\t${key} :: [Number],\n`;
			break;
		case 'object':
			insideType = `\t${key} :: [${toPascalCase(key)}],\n`;
		    nestedModel = createRecordObject(testValue, key, updateError, updateBadWord)
			break;
		}
	}

	return {body: insideType, nested: nestedModel};
};

const upperFirst = (s) => {
	return s.charAt(0).toUpperCase() + s.substr(1);
}

const toPascalCase = (str) => {
	let noSpace = str.split(' ').map(upperFirst).join('');
	let noDash = noSpace.split('-').map(upperFirst).join('');
	let noUnder = noDash.split('_').map(upperFirst).join('');

	return noUnder;
};

const checkForBadWords = (word) => {
	for (let i = 0, x = badWords.length; i < x; i++)  {
		if (word === badWords[i]) {
			return word;
		}
	}

	return false;
};

const badWords = [
	'case',
	'class',
	'data',
	'default',
	'deriving',
	'do',
	'else',
	'forall',
	'if',
	'import',
	'in',
	'infix',
	'infixl',
	'infixr',
	'instance',
	'let',
	'module',
	'newtype',
	'of',
	'qualified',
	'then',
	'type',
	'where',
	'_',
	'foreign',
	'ccall',
	'as',
	'safe',
	'unsafe'
];

const makeFileHeader = (name, badWord) => {
	let extensions = "{-# LANGUAGE DeriveGeneric #-}"
	let extraAeson = "";
	if (badWord) {
		extensions += "\n{-# LANGUAGE TemplateHaskell #-}"
		extraAeson = "\nimport Data.Aeson.TH (deriveJSON, defaultOptions, Options(fieldLabelModifier))\n"
	}

	return `${extensions}

module ${name} where

import Data.Aeson${extraAeson}
import Data.Text (Text)

import GHC.Generics (Generic)

`;
};

const makeDataHeader = (name) => {
	return `data ${name} = ${name} {\n`;
};

const makeDataFooter = (recordObj) => {
	let prefix = "} deriving (Show, Eq, Generic)\n\n"
	if (recordObj.hasBadWord) {
		console.log("HERE:");
		let fmap = curryTemplateFooter(recordObj.name);

		return [prefix].concat(recordObj.badWordList.map(fmap)).join("");
	}
	return `${prefix}instance FromJSON ${recordObj.name}\n`;
};

const curryTemplateFooter = (recordName) => {
	return (badWordEntry) => {
		return makeTemplateFooter(badWordEntry, recordName);
	}
}

const makeTemplateFooter = (badWordEntry, recordName) => {
	return `$(deriveJSON defaultOptions {fieldLabelModifier = \\x ->
                                if x == "${badWordEntry.oldWord}"
                                then "${badWordEntry.newWord}"
                                else x} ''${recordName})\n`;
}

const renderRecordObj = (recordObj) => {
	console.log(recordObj);
	let others = recordObj.nestedModels.map((x) => {
		return renderNestedObj(x);
	});

	return `${makeDataHeader(recordObj.name)}${recordObj.recordBody.join('')}${makeDataFooter(recordObj)}${others}`;
};

const renderNestedObj = (recordObj) => {
	let others = recordObj.nestedModels.map((x) => {
		return renderNestedObj(x);
	});

	return `\n${makeDataHeader(recordObj.name)}${recordObj.recordBody.join('')}${makeDataFooter(recordObj)}${others}`;
};

export default SnippetHolder;
